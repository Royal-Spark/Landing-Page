<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>USAF File Forge</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    /* Deep purple color scheme */
    --primary: #7c3aed;
    --primary-dark: #6d28d9;
    --secondary: #a855f7;
    --success: #10b981;
    --error: #ef4444;
    --bg-dark: #1a0033;
    --bg-light: #2d1b69;
    --card-bg: #2d1b69;
    --text-primary: #f1f5f9;
    --text-secondary: #c4b5fd;
    --border: #4c1d95;
    --accent: #e9d5ff;
    --warning-yellow: #fbbf24;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    background-color: var(--bg-dark);
    color: var(--text-primary);
    line-height: 1.5;
    scroll-behavior: smooth;
    min-height: 100vh;
    position: relative;
}

  /* Warning Banner */
  .warning-banner {
    background: var(--warning-yellow);
    color: #000;
    text-align: center;
    padding: 6px;
    font-weight: 700;
    font-size: 0.8rem;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 200;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  }

  /* Header */
  header {
    background: rgba(45, 27, 105, 0.8);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 2rem 0;
    position: sticky;
    top: 6px; /* Account for warning banner */
    z-index: 100;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
    margin-top: 28px; /* Push down for warning banner */
  }

  .header-content {
    max-width: 1080px;
    margin: 0 auto;
    padding: 0 2rem;
    text-align: center;
  }

 h1 {
    font-size: 2.25rem;
    font-weight: 800;
    color: var(--primary);
    margin-bottom: 0.5rem;
}

.subtitle {
    color: var(--text-secondary);
    font-size: 1.125rem;
}

  /* Main layout */
  main {
    max-width: 1080px;
    margin: 1rem auto;
    padding: 0 2rem 3rem;
  }
  
  /* Main App Tabs */
  .main-tabs {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 2rem;
  }

  .main-tab {
    padding: 0.75rem 2rem;
    font-size: 1.1rem;
    font-weight: 600;
    background: transparent;
    color: var(--text-secondary);
    border: 2px solid var(--border);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .main-tab:hover {
    background: var(--bg-light);
    color: var(--text-primary);
  }

  .main-tab.active {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    border-color: var(--primary);
    box-shadow: 0 4px 20px rgba(124, 58, 237, 0.3);
  }

  .main-tab-content {
      display: none;
  }
  .main-tab-content.active {
      display: block;
  }


  /* Cards */
  .card {
    background: rgba(45, 27, 105, 0.6);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 2rem;
    margin-bottom: 2rem;
    transition: all 0.3s ease;
  }

  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 40px rgba(124, 58, 237, 0.2);
  }

  .card h2 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    color: var(--text-primary);
  }

  .step-badge {
    width: 36px;
    height: 36px;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    border-radius:30%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    font-weight: 700;
    box-shadow: 0 4px 15px rgba(124, 58, 237, 0.3);
  }

  .card p {
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 1.5rem;
  }

  /* File input */
  .file-input-wrapper {
    position: relative;
    overflow: hidden;
  }

  input[type="file"] {
    display: block;
    padding: 1rem;
    width: 100%;
    max-width: 400px;
    background: rgba(124, 58, 237, 0.1);
    border: 2px dashed rgba(124, 58, 237, 0.5);
    border-radius: 12px;
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
  }

  input[type="file"]:hover {
    background: rgba(124, 58, 237, 0.2);
    border-color: var(--primary);
  }

  /* Buttons */
  .btn {
    padding: 0.875rem 2rem;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
     text-decoration: none;
  }
  
  .btn-primary {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    box-shadow: 0 4px 20px rgba(124, 58, 237, 0.3);
  }

  .btn-primary:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 30px rgba(124, 58, 237, 0.4);
  }

  .btn-secondary {
    background: rgba(196, 181, 253, 0.1);
    color: var(--text-primary);
    border: 1px solid var(--border);
  }

  .btn-secondary:hover:not(:disabled) {
    background: rgba(196, 181, 253, 0.2);
  }

  .btn-restart {
    background: linear-gradient(135deg, #dc2626, #ef4444);
    color: white;
    box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
  }

  .btn-restart:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 30px rgba(239, 68, 68, 0.4);
  }

  .btn:disabled {
    opacity: 0.2;
    cursor: not-allowed;
  }

  /* Sub-Tabs (AI vs Manual) */
  .sub-tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 2rem;
    background: rgba(26, 0, 51, 0.5);
    padding: 0.25rem;
    border-radius: 12px;
  }

  .sub-tab {
    flex: 1;
    padding: 0.75rem 1.5rem;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: var(--text-secondary);
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .sub-tab:hover {
    color: var(--text-primary);
  }

  .sub-tab.active {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    box-shadow: 0 4px 15px rgba(124, 58, 237, 0.3);
  }

  .sub-tab-content {
    display: none;
  }

  .sub-tab-content.active {
    display: block;
  }

  /* Textareas and inputs */
  textarea, input[type="text"], select {
    width: 100%;
    padding: 1rem;
    background: rgba(26, 0, 51, 0.5);
    border: 1px solid var(--border);
    border-radius: 12px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.95rem;
    transition: all 0.3s ease;
    resize: vertical;
  }
  
  select {
      padding: 0.875rem; /* Match button padding */
  }

  textarea:focus, input[type="text"]:focus, select:focus {
    outline: none;
    border-color: var(--primary);
    background: rgba(26, 0, 51, 0.8);
    box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
  }

  .input-group {
    margin-bottom: 1.5rem;
  }

  .input-label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-weight: 500;
  }

  /* Code blocks */
  pre {
    background: rgba(26, 0, 51, 0.8);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    overflow-x: auto;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.9rem;
    line-height: 1.5;
    color: var(--accent);
    max-height: 400px;
    overflow-y: auto;
  }

  /* Progress bar */
  .progress {
    display: none;
    margin: 1.5rem 0;
  }

  .progress-bar {
    height: 6px;
    background: rgba(26, 0, 51, 0.5);
    border-radius: 3px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
    border-radius: 3px;
    width: 0%;
    transition: width 0.3s ease;
  }

  /* Alerts */
  .alert {
    padding: 1rem 1.25rem;
    border-radius: 12px;
    margin: 1rem 0;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .alert-success {
    background: rgba(16, 185, 129, 0.1);
    border: 1px solid rgba(16, 185, 129, 0.3);
    color: var(--success);
  }

  .alert-error {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
    color: var(--error);
  }

  .alert-info {
    background: rgba(124, 58, 237, 0.1);
    border: 1px solid rgba(124, 58, 237, 0.3);
    color: var(--primary);
  }

  /* Manual fields */
  .manual-fields {
    max-height: 400px;
    overflow-y: auto;
    padding-right: 0.5rem;
  }

  .manual-field {
    margin-bottom: 1.25rem;
    padding: 1rem;
    background: rgba(26, 0, 51, 0.3);
    border-radius: 12px;
  }

  .manual-field label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--text-primary);
    font-weight: 500;
  }

  .manual-field input {
    width: 100%;
    padding: 0.75rem;
    background: rgba(26, 0, 51, 0.8);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 0.95rem;
  }

  /* Button group */
  .btn-group {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-top: 1.5rem;
    align-items: center;
  }

  /* Debug panel */
  .debug-panel {
    background: rgba(0, 0, 0, 0.9);
    border: 1px solid var(--success);
    border-radius: 12px;
    padding: 1rem;
    margin-top: 2rem;
    font-family: monospace;
    font-size: 0.85rem;
    color: var(--success);
    max-height: 200px;
    overflow-y: auto;
  }

  .debug-line {
    margin: 0.25rem 0;
    opacity: 0.8;
  }

  /* Restart button container */
  .restart-container {
    text-align: center;
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border);
  }

  @media (max-width: 768px) {
    main {
      padding: 0 1rem 2rem;
    }
    
    .card {
      padding: 1.5rem;
    }
    
    .btn-group {
      flex-direction: column;
      align-items: stretch;
    }
  }
</style>
</head>
<body>
<!-- Warning Banner -->
<div class="warning-banner">
  THIS TOOL IS IN BETA TESTING - DO NOT INPUT CUI OR PII INTO THIS SYSTEM
</div>

<header>
  <div class="header-content">
    <h1>üõ†Ô∏è USAF File Forge</h1>
    <div class="subtitle">Rapid Document Automation & Template Creation</div>
  </div>
</header>

<main>
  <div class="main-tabs">
      <button class="main-tab active" onclick="switchMainTab('forge', this)">üìÑ File Forge</button>
      <button class="main-tab" onclick="switchMainTab('creator', this)">‚ú® Template Creator</button>
      <button class="main-tab" onclick="switchMainTab('placeholder', this)">üîß Placeholder</button>
  </div>

  <!-- Main Tab: File Forge -->
  <div id="forgeTab" class="main-tab-content active">
    <div class="card">
      <h2><span class="step-badge">1</span>Upload Document Template</h2>
      <!-- PDF SUPPORT: Updated paragraph -->
      <p>Select a Word (.docx), PowerPoint (.pptx), Excel (.xlsx), or fillable PDF (.pdf) template.</p>
      <div class="file-input-wrapper">
        <!-- PDF SUPPORT: Added .pdf to accept attribute -->
        <input type="file" id="templateFile" accept=".docx,.pptx,.xlsx,.pdf" onchange="handleFileChange(event, 'forge')">
      </div>
      <div id="fileInfo"></div>
    </div>

    <div class="card">
      <h2><span class="step-badge">2</span>Extract & Configure Placeholders</h2>
      <p>Placeholders (or PDF form fields) are automatically extracted. You can also re-scan manually.</p>
      <button onclick="extractPlaceholders()" id="extractBtn" class="btn btn-primary" disabled>
        üîç Extract Placeholders
      </button>
      <div id="placeholdersOutput"></div>
      
      <div id="tabsContainer" style="display: none; margin-top: 2rem;">
        <div class="sub-tabs">
          <button class="sub-tab active" onclick="switchSubTab('ai', this)">ü§ñ AI Generation</button>
          <button class="sub-tab" onclick="switchSubTab('manual', this)">‚úèÔ∏è Manual Entry</button>
        </div>
        
        <div id="aiTab" class="sub-tab-content active">
          <div class="input-group">
            <label class="input-label">AI Instructions</label>
            <select id="forgePromptSelector"></select>
          </div>
          <div class="input-group">
            <label class="input-label">Provide the AI your data or context(Required)</label>
            <textarea id="aiContext" rows="4" placeholder="Provide details relevant to the template you have uploaded. The more details, numbers, names, dates, etc that you provide the better your output will be. This can be in any format"></textarea>
          </div>
          <div class="btn-group">
              <button onclick="generateAIPrompt()" id="generateAndCopyBtn" class="btn btn-primary">üéØ Generate & Copy Prompt</button>
              <a href="https://your-custom-url.com" class="btn btn-primary" target="_blank">üöÄ Open NIPR GPT</a>
           </div>
          <pre id="aiPromptOutput" style="display: none; margin-top: 1.5rem;"></pre>
          <div class="input-group" style="margin-top: 2rem;">
            <label class="input-label">Paste AI Response (JSON)</label>
            <textarea id="jsonDataInput" rows="10" placeholder='Paste JSON here...'></textarea>
          </div>
          <button onclick="fillTemplateFromAI()" class="btn btn-primary">‚ú® Fill Template & Download</button>
        </div>
        
        <div id="manualTab" class="sub-tab-content">
          <div id="manualFields" class="manual-fields"></div>
          <button onclick="fillTemplateFromManual()" class="btn btn-primary">‚ú® Generate Document</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Tab: Template Creator -->
  <div id="creatorTab" class="main-tab-content">
      <div class="card">
          <h2><span class="step-badge">1</span>Upload Completed Document</h2>
          <p>Select a completed Word (.docx), PowerPoint (.pptx), or Excel (.xlsx) file. The tool will extract its text content. (PDFs are not supported in this mode).</p>
          <div class="file-input-wrapper">
              <input type="file" id="creatorFile" accept=".docx,.pptx,.xlsx" onchange="handleFileChange(event, 'creator')">
          </div>
          <div id="creatorFileInfo"></div>
      </div>

      <div class="card">
          <h2><span class="step-badge">2</span>Analyze & Generate Template</h2>
          <p>Review the extracted text, then generate a prompt for the AI to identify variables and suggest placeholders.</p>
          
          <div class="input-group">
            <label class="input-label">Extracted Document Text</label>
            <textarea id="creatorExtractedText" rows="10" placeholder="Text from your document will appear here..."></textarea>
          </div>

          <div class="input-group">
            <label class="input-label">AI Instructions</label>
            <select id="creatorPromptSelector"></select>
          </div>

          <div class="btn-group">
            <button onclick="generateTemplateAIPrompt()" id="generateTemplatePromptBtn" class="btn btn-primary" disabled>
              üéØ Generate AI Prompt for Template
            </button>
          </div>
          
          <pre id="creatorAIPromptOutput" style="display: none; margin-top: 1.5rem;"></pre>
          
          <div class="input-group" style="margin-top: 2rem;">
            <label class="input-label">Paste AI Response (JSON)</label>
            <textarea id="creatorJsonDataInput" rows="10" placeholder='Paste AI response here...'></textarea>
          </div>
          
          <button onclick="createTemplateFromAI()" id="createTemplateBtn" class="btn btn-primary" disabled>
            ‚ú® Create & Download Template
          </button>
      </div>
  </div>

  <!-- Main Tab: Placeholder -->
  <div id="placeholderTab" class="main-tab-content">
      <div class="card">
          <h2><span class="step-badge">?</span>Future Tool</h2>
          <p>This section is reserved for a future tool. Check back later for updates!</p>
      </div>
  </div>

  <!-- Debug Panel -->
  <div class="debug-panel" id="debugPanel">
    <div>üêõ Debug Output:</div>
    <div id="debugOutput"></div>
  </div>

  <!-- Restart Button -->
  <div class="restart-container">
    <button onclick="restartTool()" class="btn btn-restart">
      üîÑ Restart Tool
    </button>
  </div>
</main>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<!-- PDF SUPPORT: Added pdf-lib script -->
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script>
// --- CUSTOM PROMPT CONFIGURATION ---
// Add or edit your custom prompts for the "File Forge" workflow here.
const customForgePrompts = [
    {
        name: "Standard Content",
        text: "Please fill these placeholders with appropriate, professional content."
    },
    {
        "name": "100 ARW Project One-Pager",
        "text": "Generate content for a project one-pager aligned with the 100th Air Refueling Wing mission. Detail the project's objective and how it enhances air refueling, combat support, or European theater operations. Specify key performance indicators, required resources (personnel, equipment, funding), a projected timeline with major milestones, and anticipated impact on readiness and mission effectiveness. Identify key stakeholders and potential risks."
    },
    {
        "name": "352 SOW Project One-Pager",
        "text": "Generate content for a project one-pager aligned with the 352nd Special Operations Wing mission. Describe how the project supports special operations airpower, including infiltration, exfiltration, and precision strike capabilities. Outline the project scope, strategic objectives, required specialized assets, and integration with joint/partner forces. Detail the timeline, risk assessment, and how success will be measured in the context of special warfare."
    },
    {
        "name": "48 FW Project One-Pager",
        "text": "Generate content for a project one-pager aligned with the 48th Fighter Wing mission. Explain how the project improves combat airpower, readiness, or support operations for the Liberty Wing. Define the project's goals, connection to F-15/F-35 operations, expected outcomes for sortie generation or lethality, required budget, personnel, and a clear timeline. Summarize the project's contribution to NATO objectives and air superiority."
    },
    {
        "name": "USAF Decoration Narrative",
        "text": "Write a formal narrative for a United States Air Force decoration. Detail the individual's specific, noteworthy achievement or service. Clearly describe the action, the outcome, and the significant impact on the unit's mission, personnel, or resources. Use strong, action-oriented language appropriate for a military citation. Focus on quantifiable results where possible."
    },
    {
        "name": "USAF Memorandum for Record (MFR)",
        "text": "Draft a concise, factual Memorandum for Record (MFR). State the purpose of the memorandum clearly in the opening. Document the key details of an event, decision, or conversation, including the date, time, location, and personnel involved. Present the information chronologically and objectively, without personal opinion or speculation. Conclude with any resulting actions or decisions made."
    },
    {
        "name": "USAF LOC/LOR/LOA",
        "text": "Generate the text for a formal Letter of Counseling, Admonishment, or Reprimand. Clearly state the specific infraction or unacceptable behavior and cite the relevant AFI, UCMJ article, or standard that was violated. Describe the negative impact of the action. Detail the required corrective actions the member must take and by what date. Include a statement that further deviation will result in more severe action."
    },
    {
        "name": "After Action Report",
        "text": "Generate an After Action Report (AAR) for a recent exercise, operation, or significant event. State the overall objectives. Provide a detailed summary of what occurred. Analyze what went well (sustains) and identify the root causes. Analyze what did not go well (improves) and identify the root causes. Provide specific, actionable recommendations for improvement, including responsible parties and proposed timelines for implementation."
    }
];

const customTemplatePrompts = [
    { name: "Standard Analysis", text: "Analyze the following document text to identify variable information (like names, dates, locations, numbers, specific phrases) that should be turned into placeholders for a template." },
    { name: "Legal Document Analysis", text: "Analyze the following legal document text. Identify all specific names, dates, addresses, and monetary amounts as variables. Create placeholders for them." },
    { name: "Technical Report Analysis", text: "Analyze this technical report. Identify version numbers, project codes, specific measurements, and author names as variables to be replaced with placeholders." }
];


// --- STATE MANAGEMENT ---
let forgeState = { fileBuffer: null, fileType: null, fileName: null, placeholders: [] };
let creatorState = { fileBuffer: null, fileType: null, fileName: null, fullText: '' };


// --- UTILITY FUNCTIONS ---
function debug(msg) {
  console.log(msg);
  const output = document.getElementById('debugOutput');
  if (output) {
    const time = new Date().toLocaleTimeString();
    output.innerHTML += `<div class="debug-line">[${time}] ${msg}</div>`;
    output.scrollTop = output.scrollHeight;
  }
}

function stripXmlTags(xmlString) {
    return xmlString.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
}

function xmlEncode(text) {
    if (typeof text !== 'string') return text;
    return text.replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/'/g, '&apos;')
               .replace(/"/g, '&quot;');
}


// --- INITIALIZATION & UI CONTROL ---
window.onload = function() {
  debug('Page loaded successfully');
  // PDF SUPPORT: Check for pdf-lib
  debug('pdf-lib available: ' + (typeof PDFLib !== 'undefined'));
  populatePromptDropdowns();
}

function populatePromptDropdowns() {
    const forgeSelector = document.getElementById('forgePromptSelector');
    customForgePrompts.forEach((prompt, index) => {
        forgeSelector.add(new Option(prompt.name, index));
    });

    const creatorSelector = document.getElementById('creatorPromptSelector');
    customTemplatePrompts.forEach((prompt, index) => {
        creatorSelector.add(new Option(prompt.name, index));
    });
    debug('Custom prompt dropdowns populated.');
}

function switchMainTab(tabName, button) {
    document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
    button.classList.add('active');
    document.querySelectorAll('.main-tab-content').forEach(c => c.classList.remove('active'));
    document.getElementById(tabName + 'Tab').classList.add('active');
    debug(`Switched to main tab: ${tabName}`);
}

function switchSubTab(tabName, button) {
  document.querySelectorAll('.sub-tab').forEach(t => t.classList.remove('active'));
  button.classList.add('active');
  document.querySelectorAll('.sub-tab-content').forEach(c => c.classList.remove('active'));
  document.getElementById(tabName + 'Tab').classList.add('active');
  debug(`Switched to sub-tab: ${tabName}`);
}

function restartTool() {
  if (confirm('Are you sure you want to restart? This will clear all current data.')) {
    document.getElementById('templateFile').value = '';
    document.getElementById('creatorFile').value = '';
    forgeState = { fileBuffer: null, fileType: null, fileName: null, placeholders: [] };
    creatorState = { fileBuffer: null, fileType: null, fileName: null, fullText: '' };
    resetForgeUI();
    resetCreatorUI();
    resetPlaceholderUI();
    document.getElementById('debugOutput').innerHTML = '';
    debug('Tool restarted');
  }
}

function resetForgeUI() {
    document.getElementById('fileInfo').innerHTML = '';
    document.getElementById('extractBtn').disabled = true;
    document.getElementById('placeholdersOutput').innerHTML = '';
    document.getElementById('tabsContainer').style.display = 'none';
    document.getElementById('aiContext').value = '';
    document.getElementById('aiPromptOutput').textContent = '';
    document.getElementById('aiPromptOutput').style.display = 'none';
    document.getElementById('jsonDataInput').value = '';
    document.getElementById('manualFields').innerHTML = '';
    debug('File Forge UI reset');
}

function resetCreatorUI() {
    document.getElementById('creatorFileInfo').innerHTML = '';
    document.getElementById('creatorExtractedText').value = '';
    document.getElementById('generateTemplatePromptBtn').disabled = true;
    document.getElementById('creatorAIPromptOutput').style.display = 'none';
    document.getElementById('creatorJsonDataInput').value = '';
    document.getElementById('createTemplateBtn').disabled = true;
    debug('Template Creator UI reset');
}

function resetPlaceholderUI() {
    debug('Placeholder UI reset');
}


// --- CORE LOGIC ---
function handleFileChange(event, mode) {
  const file = event.target.files[0];
  if (!file) return;

  const lowerName = file.name.toLowerCase();
  // PDF SUPPORT: Add .pdf to file type check
  const fileType = lowerName.endsWith('.docx') ? 'docx' :
                   lowerName.endsWith('.pptx') ? 'pptx' :
                   lowerName.endsWith('.xlsx') ? 'xlsx' : 
                   lowerName.endsWith('.pdf')  ? 'pdf'  : null;

  const infoEl = document.getElementById(mode === 'forge' ? 'fileInfo' : 'creatorFileInfo');

  if (!fileType) {
    infoEl.innerHTML = `<div class="alert alert-error">‚ùå Please upload a supported file type.</div>`;
    return;
  }
  
  // PDF SUPPORT: Disallow PDF in creator mode
  if (mode === 'creator' && fileType === 'pdf') {
      infoEl.innerHTML = '<div class="alert alert-error">‚ùå PDF files are not supported in Template Creator mode.</div>';
      return;
  }

  const reader = new FileReader();
  reader.onload = async function(e) {
    const fileBuffer = e.target.result;
    infoEl.innerHTML = `<div class="alert alert-success">‚úÖ ${file.name} loaded</div>`;
    
    if (mode === 'forge') {
        resetForgeUI();
        infoEl.innerHTML = `<div class="alert alert-success">‚úÖ ${file.name} loaded</div>`;
        forgeState = { ...forgeState, fileBuffer, fileType, fileName: file.name };
        document.getElementById('extractBtn').disabled = false;
        debug(`Forge file loaded: ${file.name}`);
        setTimeout(() => extractPlaceholders(), 100);
    } else if (mode === 'creator') {
        resetCreatorUI();
        infoEl.innerHTML = `<div class="alert alert-success">‚úÖ ${file.name} loaded</div>`;
        creatorState = { ...creatorState, fileBuffer, fileType, fileName: file.name };
        debug(`Creator file loaded: ${file.name}`);
        setTimeout(() => extractAllText(), 100);
    }
  };
  reader.readAsArrayBuffer(file);
}

// --- FILE FORGE WORKFLOW ---
async function extractPlaceholders() {
  if (!forgeState.fileBuffer) return;
  debug('Extracting placeholders for Forge...');
  
  const output = document.getElementById('placeholdersOutput');
  const btn = document.getElementById('extractBtn');
  btn.disabled = true;

  try {
    const foundSet = new Set();
    // PDF SUPPORT: Logic to extract form field names from a PDF
    if (forgeState.fileType === 'pdf') {
        const { PDFDocument } = PDFLib;
        // FIX: Added { ignoreEncryption: true } to handle encrypted PDFs
        const pdfDoc = await PDFDocument.load(forgeState.fileBuffer, { ignoreEncryption: true });
        const form = pdfDoc.getForm();
        const fields = form.getFields();
        fields.forEach(field => {
            foundSet.add(field.getName());
        });
    } else if (forgeState.fileType === 'xlsx') {
        const workbook = XLSX.read(forgeState.fileBuffer, {type: 'buffer'});
        workbook.SheetNames.forEach(sheetName => {
            const sheet = workbook.Sheets[sheetName];
            for (const cellAddress in sheet) {
                if (cellAddress[0] === '!') continue;
                const cell = sheet[cellAddress];
                if (cell && cell.t === 's' && cell.v) {
                    const matches = cell.v.match(/\{\{[^}]+\}\}/g) || [];
                    matches.forEach(m => foundSet.add(m.replace(/\{\{|\}\}/g, '').trim()));
                }
            }
        });
    } else { // docx and pptx
        const zip = await JSZip.loadAsync(forgeState.fileBuffer);
        const filesToScan = forgeState.fileType === 'docx' 
            ? ['word/document.xml'] 
            : Object.keys(zip.files).filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml'));
        
        for (const fileName of filesToScan) {
            if (zip.files[fileName]) {
                const content = await zip.file(fileName).async('string');
                const matches = content.match(/\{\{[^}]+\}\}/g) || [];
                matches.forEach(m => foundSet.add(m.replace(/\{\{|\}\}/g, '').trim()));
            }
        }
    }
    
    forgeState.placeholders = Array.from(foundSet);
    debug(`Found ${forgeState.placeholders.length} placeholders: ${forgeState.placeholders.join(', ')}`);
    
    if (forgeState.placeholders.length === 0) {
      output.innerHTML = `<div class="alert alert-error">No placeholders or form fields found.</div>`;
      document.getElementById('tabsContainer').style.display = 'none';
    } else {
      output.innerHTML = `<div class="alert alert-success">‚úÖ Found ${forgeState.placeholders.length} placeholders/fields.</div>`;
      document.getElementById('tabsContainer').style.display = 'block';
      setupManualFields();
    }
  } catch (error) {
    debug('Placeholder extraction error: ' + error.message);
    output.innerHTML = `<div class="alert alert-error">‚ùå Error: ${error.message}</div>`;
  } finally {
    btn.disabled = false;
  }
}

function setupManualFields() {
  const container = document.getElementById('manualFields');
  container.innerHTML = '';
  forgeState.placeholders.forEach(p => {
    const div = document.createElement('div');
    div.className = 'manual-field';
    div.innerHTML = `<label>${p}</label><input type="text" id="manual_${p}" placeholder="Enter value for ${p}">`;
    container.appendChild(div);
  });
}

async function generateAIPrompt() {
  const selectedPromptIndex = document.getElementById('forgePromptSelector').value;
  const customText = customForgePrompts[selectedPromptIndex].text;
  const context = document.getElementById('aiContext').value;
  
  const prompt = `${customText}\n\n${context}\n\nPlaceholders to fill:\n${forgeState.placeholders.map(p => `- ${p}`).join('\n')}\n\nReturn as JSON:\n{\n${forgeState.placeholders.map(p => `  "${p}": "your content here"`).join(',\n')}\n}`;
  
  const promptOutput = document.getElementById('aiPromptOutput');
  promptOutput.textContent = prompt;
  try {
    await navigator.clipboard.writeText(prompt);
    const btn = document.getElementById('generateAndCopyBtn');
    btn.textContent = '‚úÖ Copied to Clipboard!';
    setTimeout(() => { btn.textContent = 'üéØ Generate & Copy Prompt'; }, 2500);
  } catch (err) {
    alert('Failed to copy prompt.');
  }
}

async function fillTemplateFromAI() {
  const jsonText = document.getElementById('jsonDataInput').value;
  try {
    const data = JSON.parse(jsonText);
    await fillTemplate(data);
  } catch (error) {
    alert('Invalid JSON: ' + error.message);
  }
}

async function fillTemplateFromManual() {
  const data = {};
  forgeState.placeholders.forEach(p => {
    const input = document.getElementById('manual_' + p);
    data[p] = input ? input.value : '';
  });
  await fillTemplate(data);
}

async function fillTemplate(data) {
  if (!forgeState.fileBuffer) return;
  debug('Filling template with data...');
  
  try {
    let blob;
    // PDF SUPPORT: Logic to fill PDF form fields
    if (forgeState.fileType === 'pdf') {
        const { PDFDocument, PDFTextField, PDFCheckBox, PDFRadioGroup, PDFDropdown, PDFOptionList } = PDFLib;
        // FIX: Added { ignoreEncryption: true } to handle encrypted PDFs
        const pdfDoc = await PDFDocument.load(forgeState.fileBuffer, { ignoreEncryption: true });
        const form = pdfDoc.getForm();

        for (const [key, value] of Object.entries(data)) {
            try {
                const field = form.getField(key);
                if (field instanceof PDFTextField) {
                    field.setText(value.toString());
                } else if (field instanceof PDFCheckBox) {
                    // Assume 'true', 'yes', 'on' means check
                    if (['true', 'yes', 'on'].includes(value.toString().toLowerCase())) {
                        field.check();
                    } else {
                        field.uncheck();
                    }
                } else if (field instanceof PDFRadioGroup) {
                    field.select(value.toString());
                } else if (field instanceof PDFDropdown || field instanceof PDFOptionList) {
                    field.select(value.toString());
                }
            } catch (e) {
                debug(`Could not find or fill PDF field: ${key}. Error: ${e.message}`);
            }
        }
        const pdfBytes = await pdfDoc.save();
        blob = new Blob([pdfBytes], { type: 'application/pdf' });
    } else if (forgeState.fileType === 'xlsx') {
        const workbook = XLSX.read(forgeState.fileBuffer, {type: 'buffer'});
        workbook.SheetNames.forEach(sheetName => {
            const sheet = workbook.Sheets[sheetName];
            for (const cellAddress in sheet) {
                if (cellAddress[0] === '!') continue;
                const cell = sheet[cellAddress];
                if (cell && cell.t === 's' && cell.v) {
                    for (const [key, value] of Object.entries(data)) {
                        const regex = new RegExp('\\{\\{\\s*' + key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*\\}\\}', 'g');
                        cell.v = cell.v.replace(regex, value || '');
                    }
                }
            }
        });
        const wbout = XLSX.write(workbook, {bookType: 'xlsx', type: 'array'});
        blob = new Blob([wbout], {type: 'application/octet-stream'});
    } else { // docx and pptx
        const zip = await JSZip.loadAsync(forgeState.fileBuffer);
        const filesToScan = forgeState.fileType === 'docx' 
            ? ['word/document.xml'] 
            : Object.keys(zip.files).filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml'));
        
        for (const fileName of filesToScan) {
            if (zip.files[fileName]) {
                let content = await zip.file(fileName).async('string');
                for (const [key, value] of Object.entries(data)) {
                    const regex = new RegExp('\\{\\{\\s*' + key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*\\}\\}', 'g');
                    content = content.replace(regex, xmlEncode(value));
                }
                zip.file(fileName, content);
            }
        }
        blob = await zip.generateAsync({type: 'blob'});
    }
    const outputName = forgeState.fileName.replace(/\.(docx|pptx|xlsx|pdf)$/, '_filled.$1');
    saveAs(blob, outputName);
    debug(`Document saved: ${outputName}`);
  } catch (error) {
    debug('Fill error: ' + error.message);
    alert('Error: ' + error.message);
  }
}

// --- TEMPLATE CREATOR WORKFLOW ---
async function extractAllText() {
    if (!creatorState.fileBuffer) return;
    debug('Extracting all text for Creator...');
    const textOutput = document.getElementById('creatorExtractedText');
    const btn = document.getElementById('generateTemplatePromptBtn');
    btn.disabled = true;
    textOutput.value = "Extracting...";

    try {
        let fullText = '';
        if (creatorState.fileType === 'xlsx') {
            const workbook = XLSX.read(creatorState.fileBuffer, { type: 'buffer' });
            const texts = [];
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const sheetTexts = [];
                for (const cellAddress in sheet) {
                    if (cellAddress[0] === '!') continue;
                    const cell = sheet[cellAddress];
                    if (cell && cell.v) sheetTexts.push(cell.v);
                }
                texts.push(`--- Sheet: ${sheetName} ---\n${sheetTexts.join('\n')}`);
            });
            fullText = texts.join('\n\n');
        } else {
            const zip = await JSZip.loadAsync(creatorState.fileBuffer);
            const filesToScan = creatorState.fileType === 'docx'
                ? ['word/document.xml']
                : Object.keys(zip.files).filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml'));

            const texts = [];
            for (const fileName of filesToScan) {
                if (zip.files[fileName]) {
                    const content = await zip.file(fileName).async('string');
                    texts.push(stripXmlTags(content));
                }
            }
            fullText = texts.join('\n\n');
        }
        creatorState.fullText = fullText;
        textOutput.value = fullText;
        btn.disabled = false;
        document.getElementById('createTemplateBtn').disabled = false;
        debug('Full text extraction complete.');
    } catch (error) {
        debug('Full text extraction error: ' + error.message);
        textOutput.value = `Error extracting text: ${error.message}`;
    }
}

async function generateTemplateAIPrompt() {
    if (!creatorState.fullText) {
        alert('Please upload a document and extract its text first.');
        return;
    }
    
    const selectedPromptIndex = document.getElementById('creatorPromptSelector').value;
    const customText = customTemplatePrompts[selectedPromptIndex].text;

    const prompt = `${customText}

For each piece of variable information you identify:
1.  Provide the exact "originalText".
2.  Suggest a concise, camelCase "placeholderName".

Return the result as a single JSON array of objects. Each object must contain "originalText" and "placeholderName".

Example Response:
[
  { "originalText": "John Doe", "placeholderName": "personName" },
  { "originalText": "15 August 2024", "placeholderName": "effectiveDate" }
]

Document Text to Analyze:
---
${creatorState.fullText}
---
`;

    const promptOutput = document.getElementById('creatorAIPromptOutput');
    promptOutput.textContent = prompt;
    promptOutput.style.display = 'block';

    try {
        await navigator.clipboard.writeText(prompt);
        const btn = document.getElementById('generateTemplatePromptBtn');
        btn.textContent = '‚úÖ Copied to Clipboard!';
        debug('Template creator AI prompt generated and copied.');
        setTimeout(() => { btn.textContent = 'üéØ Generate AI Prompt for Template'; }, 2500);
    } catch (err) {
        alert('Failed to copy prompt.');
        debug('Copy failed: ' + err);
    }
}

async function createTemplateFromAI() {
    if (!creatorState.fileBuffer) {
        alert('Please upload a document first.');
        return;
    }
    const jsonText = document.getElementById('creatorJsonDataInput').value;
    if (!jsonText) {
        alert('Please paste the AI JSON response.');
        return;
    }

    let replacements;
    try {
        replacements = JSON.parse(jsonText);
        if (!Array.isArray(replacements)) throw new Error("JSON must be an array.");
    } catch (error) {
        alert('Invalid JSON: ' + error.message);
        return;
    }

    debug('Creating template from AI response...');

    try {
        let blob;
        if (creatorState.fileType === 'xlsx') {
            const workbook = XLSX.read(creatorState.fileBuffer, { type: 'buffer' });
            workbook.SheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                for (const cellAddress in sheet) {
                    if (cellAddress[0] === '!') continue;
                    const cell = sheet[cellAddress];
                    if (cell && cell.t === 's' && cell.v) {
                        replacements.forEach(rep => {
                            if (cell.v.includes(rep.originalText)) {
                                cell.v = cell.v.replaceAll(rep.originalText, `{{${rep.placeholderName}}}`);
                            }
                        });
                    }
                }
            });
            const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
            blob = new Blob([wbout], { type: 'application/octet-stream' });
        } else {
            const zip = await JSZip.loadAsync(creatorState.fileBuffer);
            const filesToScan = creatorState.fileType === 'docx'
                ? ['word/document.xml']
                : Object.keys(zip.files).filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml'));

            for (const fileName of filesToScan) {
                if (zip.files[fileName]) {
                    let content = await zip.file(fileName).async('string');
                    replacements.forEach(rep => {
                        const replacementValue = `{{${rep.placeholderName}}}`;
                        content = content.replaceAll(xmlEncode(rep.originalText), replacementValue);
                    });
                    zip.file(fileName, content);
                }
            }
            blob = await zip.generateAsync({ type: 'blob' });
        }
        const outputName = creatorState.fileName.replace(/\.(docx|pptx|xlsx)$/, '_template.$1');
        saveAs(blob, outputName);
        debug(`Template saved: ${outputName}`);
    } catch (error) {
        debug('Template creation error: ' + error.message);
        alert('Error creating template: ' + error.message);
    }
}

</script>
</body>
</html>
